<?xml version="1.0"?> <!-- -*- sgml -*- -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
[ <!ENTITY % vg-entities SYSTEM "../../docs/xml/vg-entities.xml"> %vg-entities; ]>


<chapter id="drd-manual" xreflabel="DRD: a thread error detector">
  <title>DRD: a thread error detector</title>

<para>To use this tool, you must specify
<computeroutput>--tool=exp-drd</computeroutput>
on the Valgrind command line.</para>


<sect1 id="drd-manual.overview" xreflabel="Overview">
<title>Background</title>

<para>
DRD is a Valgrind tool for detecting errors in multithreaded C and C++
shared-memory programs. The tool works for any program that uses the
POSIX threading primitives or that uses threading concepts built on
top of the POSIX threading primitives.
</para>

<sect2 id="drd-manual.mt-progr-models" xreflabel="MT-progr-models">
<title>Multithreaded Programming Paradigms</title>

<para>
For many applications multithreading is a necessity. There are two
reasons why the use of threads may be required:
<itemizedlist>
  <listitem>
    <para>
      To model concurrent activities. Managing the state of one
      activity per thread can be a great simplification compared to
      multiplexing the states of multiple activities in a single
      thread. This is why most server and embedded software is
      multithreaded.
    </para>
  </listitem>
  <listitem>
    <para>
      To let computations run on multiple CPU cores
      simultaneously. This is why many High Performance Computing
      (HPC) applications are multithreaded.
    </para>
  </listitem>
</itemizedlist>
</para>

<para>
Multithreaded programs can use one or more of the following
paradigms. Which paradigm is appropriate a.o. depends on the
application type -- modeling concurrent activities versus HPC.
<itemizedlist>
  <listitem>
    <para>
      Locking. Data that is shared between threads may only be
      accessed after a lock is obtained on the mutex associated with
      the shared data item.  A.o. the POSIX threads library, the Qt
      library and the Boost.Thread library support this paradigm
      directly.
    </para>
  </listitem>
  <listitem>
    <para>
      Message passing. No data is shared between threads, but threads
      exchange data by passing messages to each other. Well known
      implementations of the message passing paradigm are MPI and
      CORBA.
    </para>
  </listitem>
  <listitem>
    <para>
      Software Transactional Memory (STM). Data is shared between
      threads, and shared data is updated via transactions. After each
      transaction it is verified whether there were conflicting
      transactions. If there were conflicts, the transaction is
      aborted, otherwise it is committed. This is a so-called
      optimistic approach. There is a prototype of the Intel C
      Compiler (<computeroutput>icc</computeroutput>) available that
      supports STM. Research is ongoing about the addition of STM
      support to <computeroutput>gcc</computeroutput>.
    </para>
  </listitem>
  <listitem>
    <para>
      Automatic parallelization. A compiler converts a sequential
      program into a multithreaded program. The original program may
      or may not contain parallelization hints. As an example,
      <computeroutput>gcc</computeroutput> supports OpenMP from
      version 4.3.0 on. OpenMP is a set of compiler directives which
      tell a compiler how to parallelize a C, C++ or Fortran program.
    </para>
  </listitem>
</itemizedlist>
</para>

<para>
DRD supports any combination of multithreaded programming paradigms as
long as the implementation of these paradigms is based on the POSIX
threads primitives. DRD however does not support programs that use
e.g. Linux' futexes directly. Attempts to analyze such programs with
DRD will result in false positives.
</para>

</sect2>


<sect2 id="drd-manual.pthreads-model" xreflabel="Pthreads-model">
<title>POSIX Threads Programming Model</title>

<para>
POSIX threads, also known as Pthreads, is the most widely available
threading library on Unix systems.
</para>

<para>
The POSIX threads programming model is based on the following abstractions:
<itemizedlist>
  <listitem>
    <para>
      A shared address space. All threads running within the same
      process share the same address space. All data, whether shared or
      not, is identified by its address.
    </para>
  </listitem>
  <listitem>
    <para>
      Regular load and store operations, which allow to read values
      from or to write values to the memory shared by all threads
      running in the same process.
    </para>
  </listitem>
  <listitem>
    <para>
      Atomic store and load-modify-store operations. While these
      are not mentioned in the POSIX threads standard, most
      microprocessors support atomic memory operations. And some
      compilers provide direct support for atomic memory operations
      through built-in functions like
      e.g. <computeroutput>__sync_fetch_and_add()</computeroutput>.
    </para>
  </listitem>
  <listitem>
    <para>
      Threads. Each thread represents a concurrent activity.
    </para>
  </listitem>
  <listitem>
    <para>
      Synchronization objects and operations on these synchronization
      objects. The following types of synchronization objects are
      defined in the POSIX threads standard: mutexes, condition
      variables, semaphores, reader-writer locks, barriers and
      spinlocks.
    </para>
  </listitem>
</itemizedlist>
</para>

<para>
Which source code statements generate which memory accesses depends on
the memory model of the programming language being used. There is not
yet a definitive memory model for the C and C++ languagues. For a
draft memory model, see also document <ulink
url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2338.html">
WG21/N2338</ulink>.
</para>

<para>
For more information about POSIX threads, see also the Single UNIX
Specification version 3, also known as
<ulink url="http://www.unix.org/version3/ieee_std.html">
IEEE Std 1003.1</ulink>.
</para>

</sect2>


<sect2 id="drd-manual.mt-problems" xreflabel="MT-Problems">
<title>Multithreaded Programming Problems</title>

<para>
Depending on how multithreading is expressed in a program, one or more
of the following problems can be triggered by a multithreaded program:
<itemizedlist>
  <listitem>
    <para>
      Data races. One or more threads access the same memory
      location without sufficient locking.
    </para>
  </listitem>
  <listitem>
    <para>
      Lock contention. One thread blocks the progress of one or more other
      threads by holding a lock too long.
    </para>
  </listitem>
  <listitem>
    <para>
      Improper use of the POSIX threads API. The most popular POSIX
      threads implementation, NPTL, is optimized for speed. The NPTL
      will not complain on certain errors, e.g. when a mutex is locked
      in one thread and unlocked in another thread.
    </para>
  </listitem>
  <listitem>
    <para>
      Deadlock. A deadlock occurs when two or more threads wait for
      each other indefinitely.
    </para>
  </listitem>
  <listitem>
    <para>
      False sharing. If threads that run on different processor cores
      access different variables located in the same cache line
      frequently, this will slow down the involved threads a lot due
      to frequent exchange of cache lines.
    </para>
  </listitem>
</itemizedlist>
</para>

<para>
Although the likelihood of the occurrence of data races can be reduced
by a disciplined programming style, a tool for automatic detection of
data races is a necessity when developing multithreaded software. DRD
can detect these, as well as lock contention and improper use of the
POSIX threads API.
</para>

</sect2>


<sect2 id="drd-manual.drd-versus-helgrind" xreflabel="DRD-versus-Helgrind">
<title>Data Race Detection by DRD versus Helgrind</title>

<para>
Synchronization operations impose an order on interthread memory
accesses. This order is also known as the happens-before relationship.
</para>

<para>
A multithreaded program is data-race free if all interthread memory
accesses are ordered by synchronization operations.
</para>

<para>
A well known way to ensure that a multithreaded program is data-race
free is to ensure that a locking discipline is followed. It is e.g.
possible to associate a mutex with each shared data item, and to hold
a lock on the associated mutex while the shared data is accessed.
</para>

<para>
All programs that follow a locking discipline are data-race free, but
not all data-race free programs follow a locking discipline. There
exist multithreaded programs where access to shared data is arbitrated
via condition variables, semaphores or barriers. As an example, a
certain class of HPC applications consists of a sequence of
computation steps separated in time by barriers, and where these
barriers are the only means of synchronization.
</para>

<para>
There exist two different algorithms for verifying the correctness of
multithreaded programs at runtime. The so-called Eraser algorithm
verifies whether all shared memory accesses follow a consistent
locking strategy. And the happens-before data race detectors verify
directly whether all interthread memory accesses are ordered by
synchronization operations. While the happens-before data race
detection algorithm is more complex to implement, and while it is more
sensitive to OS scheduling, it is a general approach that works for
all classes of multithreaded programs. Furthermore, the happens-before
data race detection algorithm does not report any false positives.
</para>

<para>
DRD is based on the happens-before algorithm, while Helgrind uses a
variant of the Eraser algorithm.
</para>

</sect2>


</sect1>


<sect1 id="drd-manual.using-drd" xreflabel="Using DRD">
<title>Using DRD</title>

<sect2 id="drd-manual.options" xreflabel="DRD Options">
<title>Command Line Options</title>

<para>The following command-line options are available for controlling the
behavior of the DRD tool itself:</para>

<!-- start of xi:include in the manpage -->
<variablelist id="drd.opts.list">
  <varlistentry>
    <term>
      <option><![CDATA[--check-stack-var=<yes|no> [default: no]]]></option>
    </term>
    <listitem>
      <para>
        Controls whether <constant>DRD</constant> reports data races
        for stack variables. This is disabled by default in order to
        accelerate data race detection. Most programs do not share
        stack variables over threads.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <option><![CDATA[--exclusive-threshold=<n> [default: off]]]></option>
    </term>
    <listitem>
      <para>
        Print an error message if any mutex or writer lock is held
        longer than the specified time (in milliseconds). This option
        is intended to allow detection of lock contention.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <option>
        <![CDATA[--report-signal-unlocked=<yes|no> [default: yes]]]>
      </option>
    </term>
    <listitem>
      <para>
        Whether to report calls to
        <function>pthread_cond_signal()</function> and
        <function>pthread_cond_broadcast()</function>where the mutex
        associated with the signal via
        <function>pthread_cond_wait()</function> or
        <function>pthread_cond_timed_wait()</function>is not locked at
        the time the signal is sent.  Sending a signal without holding
        a lock on the associated mutex is a common programming error
        which can cause subtle race conditions and unpredictable
        behavior. There exist some uncommon synchronization patterns
        however where it is safe to send a signal without holding a
        lock on the associated mutex.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <option><![CDATA[--segment-merging=<yes|no> [default: yes]]]></option>
    </term>
    <listitem>
      <para>
        Controls segment merging. Segment merging is an algorithm to
        limit memory usage of the data race detection
        algorithm. Disabling segment merging may improve the accuracy
        of the so-called 'other segments' displayed in race reports
        but can also trigger an out of memory error.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <option><![CDATA[--shared-threshold=<n> [default: off]]]></option>
    </term>
    <listitem>
      <para>
        Print an error message if a reader lock is held longer than
        the specified time (in milliseconds). This option is intended
        to allow detection of lock contention.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <option><![CDATA[--show-confl-seg=<yes|no> [default: yes]]]></option>
    </term>
    <listitem>
      <para>
         Show conflicting segments in race reports. Since this
         information can help to find the cause of a data race, this
         option is enabled by default. Disabling this option makes the
         output of DRD more compact.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <option><![CDATA[--show-stack-usage=<yes|no> [default: no]]]></option>
    </term>
    <listitem>
      <para>
        Print stack usage at thread exit time. When there is a large
        number of threads created in a program it becomes important to
        limit the amount of virtual memory allocated for thread
        stacks. This option makes it possible to observe the maximum
        number of bytes that has been used by the client program for
        thread stacks. Note: the DRD tool allocates some temporary
        data on the client thread stack. The space needed for this
        temporary data is not reported via this option.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <option><![CDATA[--var-info=<yes|no> [default: no]]]></option>
    </term>
    <listitem>
      <para>
        Display the names of global, static and stack variables when a
        data race is reported. While this information can be very
        helpful, by default it is not loaded into memory since for big
        programs reading in all debug information at once may cause an
        out of memory error.
      </para>
    </listitem>
  </varlistentry>
</variablelist>
<!-- end of xi:include in the manpage -->

<!-- start of xi:include in the manpage -->
<para>
The following options are available for monitoring the behavior of the
process being analyzed with DRD:
</para>

<variablelist id="drd.debugopts.list">
  <varlistentry>
    <term>
      <option><![CDATA[--trace-addr=<address> [default: none]]]></option>
    </term>
    <listitem>
      <para>
        Trace all load and store activity for the specified
        address. This option may be specified more than once.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <option><![CDATA[--trace-barrier=<yes|no> [default: no]]]></option>
    </term>
    <listitem>
      <para>
        Trace all barrier activity.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <option><![CDATA[--trace-cond=<yes|no> [default: no]]]></option>
    </term>
    <listitem>
      <para>
        Trace all condition variable activity.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <option><![CDATA[--trace-fork-join=<yes|no> [default: no]]]></option>
    </term>
    <listitem>
      <para>
        Trace all thread creation and all thread termination events.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <option><![CDATA[--trace-mutex=<yes|no> [default: no]]]></option>
    </term>
    <listitem>
      <para>
        Trace all mutex activity.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <option><![CDATA[--trace-rwlock=<yes|no> [default: no]]]></option>
    </term>
    <listitem>
      <para>
         Trace all reader-writer lock activity.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <option><![CDATA[--trace-semaphore=<yes|no> [default: no]]]></option>
    </term>
    <listitem>
      <para>
        Trace all semaphore activity.
      </para>
    </listitem>
  </varlistentry>
</variablelist>
<!-- end of xi:include in the manpage -->

</sect2>


<sect2 id="drd-manual.data-races" xreflabel="Data Races">
<title>Data Races</title>

<para>
DRD prints a message every time it detects a data race. You should be
aware of the following when interpreting DRD's output:
<itemizedlist>
  <listitem>
    <para>
      Every thread is assigned two <emphasis>thread ID's</emphasis>:
      one thread ID is assigned by the Valgrind core and one thread ID
      is assigned by DRD. Both thread ID's start at one. Valgrind
      thread ID's are reused when one thread finishes and another
      thread is created. DRD does not reuse thread ID's. Thread ID's
      are displayed e.g. as follows: 2/3, where the first number is
      Valgrind's thread ID and the second number is the thread ID
      assigned by DRD.
    </para>
  </listitem>
  <listitem>
    <para>
      The term <emphasis>segment</emphasis> refers to a consecutive
      sequence of load, store and synchronization operations, all
      issued by the same thread. A segment always starts and ends at a
      synchronization operation. Data race analysis is performed
      between segments instead of between individual load and store
      operations because of performance reasons.
    </para>
  </listitem>
  <listitem>
    <para>
      There are always at least two memory accesses involved in a data
      race. Memory accesses involved in a data race are called
      <emphasis>conflicting memory accesses</emphasis>. DRD prints a
      report for each memory access that conflicts with a past memory
      access.
    </para>
  </listitem>
</itemizedlist>
</para>

<para>
Below you can find an example of a message printed by DRD when it
detects a data race:
</para>
<programlisting><![CDATA[
$ valgrind --tool=exp-drd --var-info=yes exp-drd/tests/rwlock_race
...
==9466== Thread 3:
==9466== Conflicting load by thread 3/3 at 0x006020b8 size 4
==9466==    at 0x400B6C: thread_func (rwlock_race.c:29)
==9466==    by 0x4C291DF: vg_thread_wrapper (drd_pthread_intercepts.c:186)
==9466==    by 0x4E3403F: start_thread (in /lib64/libpthread-2.8.so)
==9466==    by 0x53250CC: clone (in /lib64/libc-2.8.so)
==9466== Location 0x6020b8 is 0 bytes inside local var "s_racy"
==9466== declared at rwlock_race.c:18, in frame #0 of thread 3
==9466== Other segment start (thread 2/2)
==9466==    at 0x4C2847D: pthread_rwlock_rdlock* (drd_pthread_intercepts.c:813)
==9466==    by 0x400B6B: thread_func (rwlock_race.c:28)
==9466==    by 0x4C291DF: vg_thread_wrapper (drd_pthread_intercepts.c:186)
==9466==    by 0x4E3403F: start_thread (in /lib64/libpthread-2.8.so)
==9466==    by 0x53250CC: clone (in /lib64/libc-2.8.so)
==9466== Other segment end (thread 2/2)
==9466==    at 0x4C28B54: pthread_rwlock_unlock* (drd_pthread_intercepts.c:912)
==9466==    by 0x400B84: thread_func (rwlock_race.c:30)
==9466==    by 0x4C291DF: vg_thread_wrapper (drd_pthread_intercepts.c:186)
==9466==    by 0x4E3403F: start_thread (in /lib64/libpthread-2.8.so)
==9466==    by 0x53250CC: clone (in /lib64/libc-2.8.so)
...
]]></programlisting>

<para>
The above report has the following meaning:
<itemizedlist>
  <listitem>
    <para>
      The number in the column on the left is the process ID of the
      process being analyzed by DRD.
    </para>
  </listitem>
  <listitem>
    <para>
      The first line ("Thread 3") tells you Valgrind's thread ID for
      the thread in which context the data race was detected.
    </para>
  </listitem>
  <listitem>
    <para>
      The next line tells which kind of operation was performed (load
      or store) and by which thread. Both Valgrind's and DRD's thread
      ID's are displayed. On the same line the start address and the
      number of bytes involved in the conflicting access are also
      displayed.
    </para>
  </listitem>
  <listitem>
    <para>
      Next, the call stack of the conflicting access is displayed. If
      your program has been compiled with debug information (-g), this
      call stack will include file names and line numbers. The two
      bottommost frames in this call stack (<function>clone</function>
      and <function>start_thread</function>) show how the NPTL starts a
      thread. The third frame (<function>vg_thread_wrapper</function>)
      is added by DRD. The fourth frame
      (<function>thread_func</function>) is interesting because it
      shows the thread entry point, that is the function that has been
      passed as the third argument to
      <function>pthread_create()</function>.
    </para>
  </listitem>
  <listitem>
    <para>
      Next, the allocation context for the conflicting address is
      displayed. For static and stack variables the allocation context
      is only shown when the option
      <computeroutput>--var-info=yes</computeroutput> has been
      specified. Otherwise DRD will print <computeroutput>Allocation
      context: unknown</computeroutput> for such variables.
    </para>
  </listitem>
  <listitem>
    <para>
      A conflicting access involves at least two memory accesses. For
      one of these accesses an exact call stack is displayed, and for
      the other accesses an approximate call stack is displayed,
      namely the start and the end of the segments of the other
      accesses. This information can be interpreted as follows:
      <orderedlist>
        <listitem>
          <para>
            Start at the bottom of both call stacks, and count the
            number stack frames with identical function name, file
            name and line number. In the above example the three
            bottommost frames are identical
            (<function>clone</function>,
            <function>start_thread</function> and
            <function>vg_thread_wrapper</function>).
          </para>
        </listitem>
        <listitem>
          <para>
            The next higher stack frame in both call stacks now tells
            you between in which source code region the other memory
            access happened. The above output tells that the other
            memory access involved in the data race happened between
            source code lines 28 and 30 in file
            <computeroutput>rwlock_race.c</computeroutput>.
          </para>
        </listitem>
      </orderedlist>
    </para>
  </listitem>
</itemizedlist>
</para>

</sect2>


<sect2 id="drd-manual.lock-contention" xreflabel="Lock Contention">
<title>Lock Contention</title>

<para>
Threads should be able to make progress without being blocked by other
threads.  Unfortunately this is not always true.  Sometimes a thread
has to wait until a mutex or reader-writer lock is unlocked by another
thread. This is called <emphasis>lock contention</emphasis>. The more
granular the locks are, the less likely lock contention will
occur. The most unfortunate situation occurs when I/O is performed
while a lock is held.
</para>

<para>
Lock contention causes delays and hence should be avoided. The two
command line options
<literal>--exclusive-threshold=&lt;n&gt;</literal> and
<literal>--shared-threshold=&lt;n&gt;</literal> make it possible to
detect lock contention by making DRD report any lock that is held
longer than the specified threshold. An example:
</para>
<programlisting><![CDATA[
$ valgrind --tool=exp-drd --exclusive-threshold=10 exp-drd/tests/hold_lock -i 500
...
==10668== Acquired at:
==10668==    at 0x4C267C8: pthread_mutex_lock (drd_pthread_intercepts.c:395)
==10668==    by 0x400D92: main (hold_lock.c:51)
==10668== Lock on mutex 0x7fefffd50 was held during 503 ms (threshold: 10 ms).
==10668==    at 0x4C26ADA: pthread_mutex_unlock (drd_pthread_intercepts.c:441)
==10668==    by 0x400DB5: main (hold_lock.c:55)
...
]]></programlisting>

<para>
The <literal>hold_lock</literal> test program holds a lock as long as
specified by the <literal>-i</literal> (interval) argument. The DRD
output reports that the lock acquired at line 51 in source file
<literal>hold_lock.c</literal> and released at line 55 was held during
503 ms, while a threshold of 10 ms was specified to DRD.
</para>

</sect2>


<sect2 id="drd-manual.api-checks" xreflabel="API Checks">
<title>Misuse of the POSIX threads API</title>

<para>
  DRD is able to detect and report the following misuses of the POSIX
  threads API:
  <itemizedlist>
    <listitem>
      <para>
        Passing the address of one type of synchronization object
        (e.g. a mutex) to a POSIX API call that expects a pointer to
        another type of synchronization object (e.g. a condition
        variable).
      </para>
    </listitem>
    <listitem>
      <para>
        Attempt to unlock a mutex that has not been locked.
      </para>
    </listitem>
    <listitem>
      <para>
        Attempt to unlock a mutex that was locked by another thread.
      </para>
    </listitem>
    <listitem>
      <para>
        Attempt to lock a mutex of type
        <literal>PTHREAD_MUTEX_NORMAL</literal> or a spinlock
        recursively.
      </para>
    </listitem>
    <listitem>
      <para>
        Destruction or deallocation of a locked mutex.
      </para>
    </listitem>
    <listitem>
      <para>
        Sending a signal to a condition variable while no lock is held
        on the mutex associated with the signal.
      </para>
    </listitem>
    <listitem>
      <para>
        Calling <function>pthread_cond_wait()</function> with a mutex
        that is not locked, that is locked by another thread or that
        has been locked recursively.
      </para>
    </listitem>
    <listitem>
      <para>
        Associating two different mutexes with a condition variable
        via <function>pthread_cond_wait()</function>.
      </para>
    </listitem>
    <listitem>
      <para>
        Destruction or deallocation of a condition variable that is
        being waited upon.
      </para>
    </listitem>
    <listitem>
      <para>
        Destruction or deallocation of a locked reader-writer lock.
      </para>
    </listitem>
    <listitem>
      <para>
        Attempt to unlock a reader-writer lock that was not locked by
        the calling thread.
      </para>
    </listitem>
    <listitem>
      <para>
        Attempt to recursively lock a reader-writer lock exclusively.
      </para>
    </listitem>
    <listitem>
      <para>
        Reinitialization of a mutex, condition variable, reader-writer
        lock, semaphore or barrier.
      </para>
    </listitem>
    <listitem>
      <para>
        Destruction or deallocation of a semaphore or barrier that is
        being waited upon.
      </para>
    </listitem>
    <listitem>
      <para>
        Exiting a thread without first unlocking the spinlocks,
        mutexes or reader-writer locks that were locked by that
        thread.
      </para>
    </listitem>
  </itemizedlist>
</para>

</sect2>


<sect2 id="drd-manual.clientreqs" xreflabel="Client requests">
<title>Client Requests</title>

<para>
Just as for other Valgrind tools it is possible to pass information
from a client program to the DRD tool.
</para>

</sect2>


<sect2 id="drd-manual.openmp" xreflabel="OpenMP">
<title>Debugging OpenMP Programs With DRD</title>

<para>
For more information about OpenMP, see also 
<ulink url="http://openmp.org/">openmp.org</ulink>.
</para>

</sect2>


</sect1>


<sect1 id="drd-manual.limitations" xreflabel="Limitations">
<title>Limitations</title>

<para>DRD currently has the following limitations:</para>

<itemizedlist>
  <listitem>
    <para>
      DRD has only been tested on the Linux operating system, and not
      on any of the other operating systems supported by
      Valgrind.
    </para>
  </listitem>
  <listitem>
    <para>
      Of the two POSIX threads implementations for Linux, only the
      NPTL (Native POSIX Thread Library) is supported. The older
      LinuxThreads library is not supported.
    </para>
  </listitem>
  <listitem>
    <para>
      When running DRD on a PowerPC CPU, DRD will report false
      positives on atomic operations. See also Valgrind bug <ulink
      url="http://bugs.kde.org/show_bug.cgi?id=162354">
      162354</ulink>.
    </para>
  </listitem>
  <listitem>
    <para>
      DRD, just like memcheck, will refuse to start on Linux
      distributions where all symbol information has been removed from
      ld.so. This is a.o. the case for the PPC editions of openSUSE
      and Gentoo. You will have to install the glibc debuginfo package
      on these platforms before you can use DRD. See also openSUSE bug
      <ulink url="http://bugzilla.novell.com/show_bug.cgi?id=396197">
      396197</ulink> and Gentoo bug <ulink
      url="http://bugs.gentoo.org/214065">214065</ulink>.
    </para>
  </listitem>
  <listitem>
    <para>
      When DRD prints a report about a data race detected on a stack
      variable in a parallel section of an OpenMP program, the report
      will contain no information about the context of the data race
      location (<computeroutput>Allocation context:
      unknown</computeroutput>). It's not yet clear whether this
      behavior is caused by Valgrind or by gcc.
    </para>
  </listitem>
  <listitem>
    <para>
      If you compile the DRD source code yourself, you need gcc 3.0 or
      later. gcc 2.95 is not supported.
    </para>
  </listitem>

</itemizedlist>

</sect1>


<sect1 id="drd-manual.feedback" xreflabel="Feedback">
<title>Feedback</title>

<para>
If you have any comments, suggestions, feedback or bug reports about
DRD, feel free to either post a message on the Valgrind users mailing
list or to file a bug report. See also <ulink
url="&vg-url;">&vg-url;</ulink> for more information about the
Valgrind mailing lists and how to file a bug report.
</para>

</sect1>


</chapter>
